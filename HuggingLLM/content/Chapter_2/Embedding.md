# ChatGPT使用指南——相似匹配
## 1. Embedding
### 使用模型步骤
#### Step1： token化
* 按字
* 按词
* 按Bi-Gram
#### Step2：表示token
* one-Hot编码  

  问题：
    1. 数据维度太高：太高的维度会导致向量在空间中聚集在一个非常狭窄的角落，模型难以训练。
    2. 数据稀疏，向量之间缺乏语义上的交互（语义鸿沟）

* Embedding  
主要思想：
    1. 把特征固定在某一个维度D，避免维度过高的问题。
    2. 利用自然语言文本的上下文关系学习一个稠密表示。也就是说，每个Token的表示不再是预先算好的了，而是在过程中学习到的，元素也不再是很多个0，而是每个位置都有一个小数，这D个小数构成了一个Token表示。

#### 总结一下，Embedding本质就是一组稠密向量，用来表示一段文本（可以是字、词、句、段等），获取到这个表示后，我们就可以进一步做一些任务。

## 2. 相关API
Open AI  
智谱 AI
### 2.1 LMAS Embedding API
在自然语言处理领域，我们一般使用**cosine相似度**作为语义相似度的度量，评估两个向量在语义空间上的分布情况。
更多模型可以在这里查看：https://openai.com/blog/new-and-improved-embedding-model
### 2.2 ChatGPT Style

## 3. Embedding应用
### 3.1 QA
Q表示Question，A表示Answer  
关键点：
1. 事先需要有一个QA库。
2. 用户提问时，系统要能够在QA库中找到一个最相似的。

使用Kaggle提供的Quora数据集：https://www.kaggle.com/general/183270

做QA任务首先得有一个QA库，这些QA就是我们的仓库，每当一个新的问题过来时，我们就用这个问题去和咱们仓库里的每一个Q去匹配，然后找到最相似的那个，接下来就把该问题的Answer当做新问题的Answer交给用户。

任务的核心就是如何找到这个最相似的，涉及两个知识点：如何表示一个Question，以及如何查找到相似的Question。  
对于第一点，用API提供的Embedding表示，我们可以把它当做一个黑盒子，输入任意长度的文本，输出一个向量。查找相似问题则主要是用到相似度算法，语义相似度一般用cosine距离来衡量。
### 3.2 聚类
使用Kaggle的DBPedia数据集：https://www.kaggle.com/datasets/danofer/dbpedia-classes?select=DBPEDIA_val.csv
### 3.3 推荐
新闻推荐逻辑：
- 首先要有一个基础的文章库，可能包括标题、内容、标签等。
- 计算已有文章的Embedding并存储。
- 根据用户浏览记录，推荐和浏览记录最相似的文章。  

数据集：https://www.kaggle.com/datasets/amananandrai/ag-news-classification-dataset?select=train.csv  
QA使用的是用户的Question去匹配已有知识库，而推荐是使用用户的浏览记录去匹配。但是很明显，推荐相比QA要更复杂一些，主要包括以下几个方面：
- 刚开始用户没有记录时的推荐（一般行业称为冷启动问题）。
- 除了相似还有其他要考虑的因素：比如热门内容、新内容、内容多样性、随时间变化的兴趣变化等等。
- 编码（Embedding输入）问题：我们应该取标题呢，还是文章，还是简要描述或者摘要，还是都要计算。
- 规模问题：推荐面临的量级一般会远超QA，除了横向扩展机器，是否能从流程和算法设计上提升效率。
- 用户反馈对推荐系统的影响问题：用户反感或喜欢与文章本身并没有直接关系，比如用户喜欢体育新闻但讨厌中国足球。
- 线上实时更新问题。

综合考虑上面的因素设计出一个比较简单的方案：
- 用户注册登录时，让其选择感兴趣的类型（如体育、音乐、时尚等），我们通过这一步将用户框在一个大的范围内，同时用来顺道解决冷启动问题。
- 给用户推荐内容时，在知道类别（用户注册时选择+浏览记录）后，应依次考虑时效性、热门程度、多样性等。
- 考虑到性能问题，可以编码「标题+摘要」。
- 对大类别进一步细分，只在细分类别里进行相似度计算。
- 记录用户实时行为（如浏览Item、浏览时长、评论、收藏、点赞、转发等）。
- 动态更新内容库，更新用户行为库。

在具体实施时，我们使用最常用的流程线方案：召回+排序。
- 召回：通过各种不同属性或特征（如用户偏好、热点、行为等）先找到一批要推荐列表。
- 排序：根据多样性、时效性、用户反馈、热门程度等属性对结果进行排序。

实际中有很多细节或优化点需要注意，比如：

- 建数据库表（上面的`get_`其实都是查表）
- 将Item、User和Action也进行Embedding，全部使用Embedding后再做召回
- 对『感兴趣`get_most_interested_item`』更多的优化，考虑更多行为和反馈，召回更多不同类型条目
- 性能和自动更新数据的考虑
- 线上评测，A/B等